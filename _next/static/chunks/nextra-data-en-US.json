{"/_app":{"title":" App","data":{"":""}},"/demo":{"title":"Demo","data":{"":""}},"/docs/advanced":{"title":"Advanced Usage","data":{"":"","list-name-services#List Name Services":"To list all registered name services, you can call the listServices method. Here's an example:\nimport nameMatcha from '@leapwallet/name-matcha'\n\nconst services = nameMatcha.listServices()\n// ['icns', 'ibcDomains', 'stargazeNames', 'archIds', 'spaceIds', 'sns', 'nibId', 'degeNS']","custom-name-services#Custom Name Services":"This library allows you to define and register your own name services.","defining-a-name-service#Defining a Name Service":"A name service is a class that implements the NameService interface. Here's an example of ICNS2 name service:\nimport { decode } from 'bech32'\nimport {\nAllowedTopLevelDomains,\nMatchaError,\nMatchaErrorType,\nNameService,\nNetwork,\nRpcURLs\n} from '@leapwallet/name-matcha'\n\nconst rpcUrls = {\nmainnet: 'https://rpc.cosmos.directory/osmosis',\ntestnet: 'https://rpc-test.osmosis.zone'\n}\n\n// make sure this is unique\nexport const serviceID = 'icns2'\n\nexport class ICNS2 extends NameService {\nserviceID = serviceID\nchain = 'osmosis'\ncontractAddress = {\nmainnet: 'osmo1xk0s8xgktn9x5vwcgtjdxqzadg88fgn33p8u9cnpdxwemvxscvast52cdd',\ntestnet: 'osmo1q2qpencrnnlamwalxt6tac2ytl35z5jejn0v4frnp6jff7gwp37sjcnhu5'\n}\n\nasync resolve(\nname: string,\nnetwork: Network,\noptions?: {\nallowedTopLevelDomains?: AllowedTopLevelDomains\nrpcUrls?: RpcURLs\n}\n): Promise<string> {\nconst client = await this.getCosmWasmClient(\noptions?.rpcUrls?.[serviceID]?.[network] ?? rpcUrls[network]\n)\n\nconst [username, prefix] = name.split('.')\n// place your logic here\ntry {\nconst res = await client?.queryContractSmart(\nthis.contractAddress[network],\n{\naddress: {\nname: username,\nbech32_prefix: prefix\n}\n}\n)\nif (\n!res?.address ||\nallowedTopLevelDomains?.icns?.indexOf(prefix) === -1\n) {\nthrow new MatchaError('', MatchaErrorType.NOT_FOUND)\n}\nreturn res.address\n} catch (e) {\nthrow new MatchaError('', MatchaErrorType.NOT_FOUND)\n}\n}\n\nasync lookup(address: string, network: Network, options?: {\nrpcUrls?: RpcURLs\n}): Promise<string> {\nconst client = await this.getCosmWasmClient(\noptions?.rpcUrls?.[serviceID]?.[network] ?? rpcUrls[network]\n)\n\nconst { prefix } = decode(address)\n// place your logic here\ntry {\nconst res = await client?.queryContractSmart(\nthis.contractAddress[network],\n{\nprimary_name: {\naddress\n}\n}\n)\nif (!res?.name) {\nthrow new MatchaError('', MatchaErrorType.NOT_FOUND)\n}\nreturn `${res.name}.${prefix}`\n} catch (e) {\nthrow new MatchaError('', MatchaErrorType.NOT_FOUND)\n}\n}\n}\nThe this.getCosmWasmClient{:ts} method is a helper method that returns a CosmWasmClient instance. It is built into the NameService abstract class so you can use it in your own name service. Everything is taken care of for you.","registering-a-name-service#Registering a Name Service":"To register a name service, you need to call the registerNameService method. Here's an example:\nimport nameMatcha, { services } from '@leapwallet/name-matcha'\n\nimport { ICNS2, serviceID as icns2Id } from './icns2'\n\n// add the service ID to the services object\nconst allServices = {\n// built-in services\n...services,\n// your custom icns2 service\n[icns2Id]: icns2Id\n}\n\nnameMatcha.registerNameService(new ICNS2())"}},"/docs":{"title":"Getting Started","data":{"":"","motivation#Motivation":"There are many ways to identify a wallet address in the cosmos universe. The most common way is to use the bech32 address format. However, this format is not very user-friendly. It is also not very easy to remember. This is why we need a way to identify a wallet address by a human-readable name.For this purpose, the community has come up with quite a few name-services, a few popular ones are:\nICNS\nStargaze Names\nIBC Domains\nArchId\nSpaceId\nSNS\n\nThese services allow users to register a name for their wallet address. However, there is no standard way to resolve these names to wallet addresses. This is where Name Matcha comes in. It is a javascript library that allows you to resolve names to wallet addresses in a standard way.Just a single line of code is all you need to resolve a name to a wallet address.","installation#Installation":"You can use your favourite package manager to install the library\n\n\nyarn add @leapwallet/name-matcha\n\n\n\nnpm install @leapwallet/name-matcha\n\n\n\npnpm add @leapwallet/name-matcha"}},"/docs/usage":{"title":"Usage","data":{"":"","imports#Imports":"","registry#registry":"The library exports a registry object with the required methods. You can import it like this:\nimport { registry } from '@leapwallet/name-matcha'","services#services":"The library exports a services object with the available services:\nimport { services as nameMatcha } from '@leapwallet/name-matcha'\nIt looks like this:\nconst services = {\nicns: 'icns',\nibcDomains: 'ibcDomains',\nstargazeNames: 'stargazeNames',\narchIds: 'archIds',\nspaceIds: 'spaceIds',\nsns: 'sns',\nnibId: 'nibId',\ndegeNS: 'degeNS'\n}","name-resolution#Name Resolution":"","resolve#resolve":"For resolving a name to address, you can use the resolve method. It takes two arguments:\nThe name to query\nThe service to query against\n\n\nconst address = await nameMatcha.resolve('leap_cosmos.osmo', services.icns)\nconsole.log(address); // osmo19vf5mfr40awvkefw69nl6p3mmlsnacmmzu45k9","resolveall#resolveAll":"To resolve a name to an address, for all the available services, you can use the resolveAll method. It takes one argument:\nThe name to query\n\n\nconst address = await nameMatcha.resolveAll('leap_cosmos.osmo')\nconsole.log(address);\nThe output will be an object with the service as key and the address as value:\n{\nicns: 'osmo19vf5mfr40awvkefw69nl6p3mmlsnacmmzu45k9',\nibcDomains: null,\nstargazeNames: null,\narchIds: null,\nspaceIds: null,\nsns: null,\nnibId: null,\ndegeNS: null\n}","name-lookup#Name Lookup":"","lookup#lookup":"For getting the name associated to an address, you can use the lookup method. It takes two arguments:\nThe address to query\nThe service to query against\n\n\nconst name = await nameMatcha.lookup('osmo19vf5mfr40awvkefw69nl6p3mmlsnacmmzu45k9', services.icns)\nconsole.log(name); // leap_cosmos.osmo","lookupall#lookupAll":"To get the name associated to an address, for all the available services, you can use the lookupAll method. It takes one argument:\nThe address to query\n\n\nconst names = await nameMatcha.lookupAll('osmo19vf5mfr40awvkefw69nl6p3mmlsnacmmzu45k9')\nThe output will be an object with the service as key and the name as value:\n{\nicns: 'leap_cosmos.osmo',\nibcDomains: 'leapwallet.osmo',\nstargazeNames: 'messi.osmo',\narchIds: null,\nspaceIds: null,\nsns: null,\nnibId: null,\ndegeNS: 'ligma.pp'\n}","switch-network#Switch Network":"By default, the library uses the mainnet network. To switch network, you can use the setNetwork method. It takes one argument:\nThe network to use\n\nHere's an example:\nnameMatcha.setNetwork('testnet')","custom-rpc-endpoints#Custom RPC Endpoints":"Name Matcha comes with default RPC endpoints for each service.","error-handling#Error Handling":"The library throws errors when something goes wrong. The library throws errors of type MatchaError. It is built on top of the Error class, and has an additional property type of type MatchaErrorType.\nimport nameMatcha, { MatchaError, MatchaErrorType } from '@leapwallet/name-matcha'\n\ntry {\nconst name = await nameMatcha.lookup('osmo19vf5mfr40awvkefw69nl6p3mmlsnacmmzu45k9', services.icns)\n} catch (error: MatchaError) {\nif (error.type === MatchaErrorType.NOT_FOUND) {\nalert('Name not found')\n}\n}","supported-chains#Supported Chains":"IBC Domains\nICNS\nStargaze Names - All Chains are Supported\nArchId - Archway\nSpaceId - Supports .inj and .sei domains\nSNS - Injective .sol domains\nNIB ID - .nibi domains on Nibiru\nDegeNS - Degen Name Service on Sei Network"}},"/":{"title":"Introducing Matcha by LeapWallet.io","data":{"":""}}}